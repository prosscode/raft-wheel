### 共识算法（Consensus Algorithm）
"共识"的意思是保证所有参与者都要用相同的认知(强一致性)，共识算法最有名的应该是Paxos算法。
Paxos算法除了难懂，还难以实现。尽管如此，在生产环境中还有有一些使用Paxos算法以及修订版的Paxos：
1. Google Chubby: 分布式锁
2. Google Spanner: NewSQL
3. Amazon Elastic Container Service

2014年斯坦福大学提出raft算法(raft.github.io)，在保证和Paxos算法一正确性的前提下，优化了Leader选举和日志复制，提高了可理解性。

### raft算法的角色
Raft算法是单Leader、多Follower模型，可以理解为主从模型。有3种角色:
1. Leader: 集群的Leader
2. Candidate: 想要成为Leader的候选者
3. Follower: Leader的跟随者

系统在启动后会马上选举出Leader，之后的请求全部通过Leader处理。Leader在处理请求时。会先加一条日志，把日志同步给Follower。
当写入成功的节点过半之后持久化日志，通知Follower也持久化，最后将结果回复给客户端。

#### 数据不一致的问题
从两个方面进行考虑和处理: 
1. 使用日志写人，而不是直接修改，保证到Follower节点的同步请求有序，而且能够重新计算出当前状态(日志状态机模型)
2. 写入时，遵循Quorum机制（折中方案，性能和数据丢失选择），也就是过半节点写人成功才算整体成功

> 使用状态机模型，就把如何保证分布式一致性的问题，转换成了如何保证所有参与的节点按照统一顺序写入的问题。
> 遵循Quorum机制，则主要关注多副本下如何保证数据读到最新副本的问题。

### 选举机制
如果Leader节点宕机了，如何从剩下的节点中选举新的Leader节点？新的节点需要满足这几个条件: 
1. 新的Leader节点肯定是需要拥有最新日志数据
2. 新的Leader节点应该有过半节点的支持，也就是说半数节点上的日志数据不会比该新Leader节点上的数据更新

最后问题转化为，如何判断剩下的节点中，谁的数据最新。
可以通过比较其它节点投票请求中的日志版本和自己本地的日志版本来确定，如果自己的版本号较大，则不支持对方。

#### 投票的问题
在设计的过程中，牵扯到投票的问题。如果剩下节点中日志版本号都是最新的，该怎么办？互相投票后，剩下节点都可能成为Leader。
减少同时成为Leader的概率，我们可能还需要要求，节点不能重复投票。
也就是说，节点收到投票请求并且不反对，则记录自己投过节点，之后不能再投票给其它节点。










